pipeline {
  agent none

  options {
    timestamps()
    disableConcurrentBuilds()
    buildDiscarder(logRotator(numToKeepStr: '30'))
    ansiColor('xterm')
    timeout(time: 60, unit: 'MINUTES')
  }

  parameters {
    choice(
      name: 'ENV',
      choices: ['staging', 'prod'],
      description: 'Entorno de despliegue'
    )
    choice(
      name: 'TARGET',
      choices: ['eks', 'aks', 'both'],
      description: 'Proveedor objetivo'
    )
  }

  environment {
    APP_NAME        = "tfm-app"
    HELM_CHART_DIR  = "deploy/apps/helm/apps"
    VALUES_BASE     = "deploy/apps/helm/apps/values.yaml"
    IMAGE_REF_DIGEST = ""
  }

  stages {

    stage('Checkout') {
      agent any
      steps {
        checkout scm
      }
    }

    stage('Build & Push Image') {
      agent { label 'linux-docker' }
      steps {
        sh """
          set -e
          echo ">>> Build y push de imagen (placeholder)"
          # Aquí iría tu build real (docker buildx, kaniko, etc.)
          # Debe devolver una referencia con digest:
          # IMAGE_REF_DIGEST=repo/app@sha256:xxxx
          echo "repo/app@sha256:dummy" > image_ref.txt
        """
        script {
          env.IMAGE_REF_DIGEST = readFile('image_ref.txt').trim()
        }
      }
    }

    stage('Deploy') {
      when {
        expression { params.ENV == 'staging' || params.ENV == 'prod' }
      }
      agent { label 'linux-docker' }

      stages {

        stage('Deploy EKS') {
          when {
            expression { params.TARGET == 'eks' || params.TARGET == 'both' }
          }
          steps {
            withCredentials([
              file(credentialsId: 'KUBECONFIG_EKS', variable: 'KUBECONFIG')
            ]) {
              sh """
                set -e
                CLOUD="eks"
                NS="${params.ENV}"
                VALUES_CLOUD="deploy/env/${params.ENV}/values/${CLOUD}.yaml"

                echo ">>> Deploy EKS | env=${NS}"
                echo ">>> Values: ${VALUES_BASE} + ${VALUES_CLOUD}"

                kubectl apply -f deploy/policies/kyverno/ || true

                helm upgrade --install "${APP_NAME}" "${HELM_CHART_DIR}" \
                  -n "${NS}" --create-namespace \
                  -f "${VALUES_BASE}" \
                  -f "${VALUES_CLOUD}" \
                  --set image.repository="$(echo ${IMAGE_REF_DIGEST} | awk -F@ '{print $1}')" \
                  --set image.digest="$(echo ${IMAGE_REF_DIGEST} | awk -F@ '{print $2}')"

                kubectl -n "${NS}" rollout status deploy \
                  -l "app.kubernetes.io/instance=${APP_NAME}" --timeout=300s
              """
            }
          }
        }

        stage('Deploy AKS') {
          when {
            expression { params.TARGET == 'aks' || params.TARGET == 'both' }
          }
          steps {
            withCredentials([
              file(credentialsId: 'KUBECONFIG_AKS', variable: 'KUBECONFIG')
            ]) {
              sh """
                set -e
                CLOUD="aks"
                NS="${params.ENV}"
                VALUES_CLOUD="deploy/env/${params.ENV}/values/${CLOUD}.yaml"

                echo ">>> Deploy AKS | env=${NS}"
                echo ">>> Values: ${VALUES_BASE} + ${VALUES_CLOUD}"

                kubectl apply -f deploy/policies/kyverno/ || true

                helm upgrade --install "${APP_NAME}" "${HELM_CHART_DIR}" \
                  -n "${NS}" --create-namespace \
                  -f "${VALUES_BASE}" \
                  -f "${VALUES_CLOUD}" \
                  --set image.repository="$(echo ${IMAGE_REF_DIGEST} | awk -F@ '{print $1}')" \
                  --set image.digest="$(echo ${IMAGE_REF_DIGEST} | awk -F@ '{print $2}')"

                kubectl -n "${NS}" rollout status deploy \
                  -l "app.kubernetes.io/instance=${APP_NAME}" --timeout=300s
              """
            }
          }
        }
      }
    }
  }

  post {
    success {
      echo "Pipeline finalizado correctamente"
    }
    failure {
      echo "Pipeline fallido"
    }
    always {
      cleanWs()
    }
  }
}